---
globs: components/**/*.jsx,features/**/*.jsx,app/**/*.jsx
description: React 组件开发规范和最佳实践
---

# React 组件规范

## 基本原则

1. **所有组件必须使用 JSDoc 类型注释**，明确 Props 类型和返回值
2. **组件应该专注于单一职责**，保持简洁和可复用
3. **使用函数式组件和 Hooks**，避免类组件
4. **所有用户可见的文本使用中文**

## 组件结构

### 1. 组件定义格式

```javascript
"use client"; // 客户端组件必须添加此指令

import { useState, useCallback } from "react";
// ... 其他导入

/**
 * @typedef {Object} ComponentNameProps
 * @property {string} title - 组件标题
 * @property {boolean} [isVisible] - 是否可见（可选）
 * @property {(value: string) => void} [onChange] - 值变化回调（可选）
 */

/**
 * 组件名称
 * 简要描述组件的功能和用途
 * 
 * @param {ComponentNameProps} props
 * @returns {JSX.Element}
 */
export function ComponentName({ title, isVisible = false, onChange }) {
  // 组件实现
}
```

### 2. Props 类型定义

使用 JSDoc `@typedef` 定义 Props 类型：

```javascript
/**
 * @typedef {Object} ButtonProps
 * @property {React.ReactNode} children - 按钮内容
 * @property {"primary" | "secondary" | "danger"} [variant="primary"] - 按钮样式变体
 * @property {boolean} [disabled=false] - 是否禁用
 * @property {() => void} [onClick] - 点击事件处理函数
 * @property {string} [className] - 额外的 CSS 类名
 */
```

### 3. 内联组件类型

对于简单的内联组件，可以直接在参数中定义类型：

```javascript
/**
 * @param {{
 *   checked: boolean;
 *   onCheckedChange: (checked: boolean) => void;
 *   disabled?: boolean;
 * }} props
 */
function Switch({ checked, onCheckedChange, disabled }) {
  // 实现
}
```

## 状态管理

### 1. 使用 useState

```javascript
// ✅ 好的实践：使用有意义的初始值
const [isOpen, setIsOpen] = useState(false);
const [count, setCount] = useState(0);

// ✅ 复杂初始状态使用函数初始化
const [state, setState] = useState(() => ({
  items: [],
  loading: false,
}));
```

### 2. 使用 useCallback 优化回调

```javascript
// ✅ 对于传递给子组件的回调，使用 useCallback
const handleClick = useCallback(() => {
  // 处理逻辑
}, [dependencies]);

// ✅ 对于事件处理，如果依赖项稳定，使用 useCallback
const handleSubmit = useCallback((e) => {
  e.preventDefault();
  onSubmit(data);
}, [data, onSubmit]);
```

### 3. 使用 useMemo 优化计算

```javascript
// ✅ 对于昂贵的计算，使用 useMemo
const filteredItems = useMemo(() => {
  return items.filter(item => item.category === selectedCategory);
}, [items, selectedCategory]);
```

## 组件组合

### 1. 组件导出

```javascript
// ✅ 默认导出主组件
export default function MainComponent() {
  // ...
}

// ✅ 或命名导出
export function ComponentName() {
  // ...
}

// ✅ 子组件可以一起导出
export function ComponentName() {
  // ...
}

export function ComponentNameHeader() {
  // ...
}
```

### 2. 条件渲染

```javascript
// ✅ 使用逻辑与运算符
{isVisible && <Component />}

// ✅ 使用三元运算符
{isLoading ? <Spinner /> : <Content />}

// ✅ 复杂条件使用函数
{renderContent()}
```

## 事件处理

### 1. 事件处理函数命名

```javascript
// ✅ 使用 handle 前缀
const handleClick = () => {};
const handleSubmit = () => {};
const handleChange = () => {};

// ✅ 或使用 on 前缀（当作为 Props 传递时）
const onClick = () => {};
const onSubmit = () => {};
```

### 2. 事件处理实现

```javascript
// ✅ 内联简单处理
<button onClick={() => setIsOpen(true)}>打开</button>

// ✅ 复杂处理使用函数
<button onClick={handleSubmit}>提交</button>

// ✅ 需要传递参数时
<button onClick={() => handleDelete(item.id)}>删除</button>
```

## 样式处理

### 1. 使用 Tailwind CSS

```javascript
// ✅ 使用 cn 工具函数合并类名
import { cn } from "@/lib/utils";

<div className={cn(
  "base-classes",
  isActive && "active-classes",
  className // 支持外部传入的类名
)}>
```

### 2. 条件样式

```javascript
// ✅ 使用 cn 处理条件样式
<button className={cn(
  "px-4 py-2 rounded",
  variant === "primary" && "bg-blue-600 text-white",
  disabled && "opacity-50 cursor-not-allowed"
)}>
```

## 参考实现

参考以下文件作为标准实现示例：
- [components/model-config-dialog.jsx](mdc:components/model-config-dialog.jsx) - 复杂对话框组件
- [components/chat-panel-optimized.jsx](mdc:components/chat-panel-optimized.jsx) - 大型业务组件
- [hooks/use-chat-state.js](mdc:hooks/use-chat-state.js) - 自定义 Hook 示例

## 避免的实践

- ❌ 在组件内部定义其他组件（除非是必要的封装）
- ❌ 使用类组件（除非有特殊需求）
- ❌ 缺少 Props 类型注释
- ❌ 在渲染函数中进行复杂计算（应使用 useMemo）
- ❌ 直接修改 Props（Props 应该是只读的）
